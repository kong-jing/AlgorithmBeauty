# AlgorithmBeauty

## 01-04开篇词

不同的设备会有不同的测试结果， 事后统计法，这个局限性很大。

\#### 大O复杂度表示法

运行代码的情况下，用肉眼可以得到一段代码的执行时间

所有代码的执行时间T(n)与每行代码的执行次数成正比

```java
/**

* functionName: cal <p>

* description: 执行时间 2n+2 <p>

* params: n <p>

* return: int <p>

* author: <p>

* date: 2020/6/8 <p>

*/

static int cal(int n) {

System.out.println(System.currentTimeMillis());

int sum = 0;

int i = 1;

for (; i <= n; ++i) {

sum = sum + i;

}

System.out.println(System.currentTimeMillis());

return sum;

}

/**

* functionName: cal2 <p>

* description: 执行时间 (2n² + 2n + 3) <p>

* params: n <p>

* return: int <p>

* author: <p>

* date: 2020/6/8 <p>

*/

static int cal2(int n) {

int sum = 0;

int i = 1;

int j = 1;

for (; i <= n; ++i) {

j = 1;

for (; j <= n; ++j) {

sum = sum + i * j;

}

}

return sum;

}

```



所以根据大O复杂度的公式，T(n) = O(f(n))

$T(n) = O(2n^2 + 2n + 3)$

只需要记住最大量级就可以了。

只关注执行次数最多的一段代码

\#### 加法法则

总复杂度等于量级最大的那段代码的复杂度

\#### 乘法法则

嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

常见的时间复杂度实例分析

常量阶 指数阶 对数阶 阶乘阶 线性阶 线性对数阶 平方阶 立方阶

阶乘阶与指数阶 是非多项式量级 非常低效。

\##### 多项式量级时间复杂度

\1. O(1)

不管代码行数，常量级时间复杂度一种表示方法。一般情况下，只要算法中不存在

循环语句，递归语句，即使有成千上万行代码，时间复杂度都是 **O(1)**

2.O(logn) O(nlogn)

非常常见，也是最难分析的一种时间复杂度。

$\log_\ n$

\##### 空间复杂度

渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系

\#### 浅析最好、最坏、平均、均摊时间复杂度

```java


// 全局变量，大小为10的数组array，长度len，下标i。

int array[] = new int[10];

int len = 10;

int i = 0;

// 往数组中添加一个元素

void add(int element) {

if (i >= len) { // 数组空间不够了

// 重新申请一个2倍大小的数组空间

int new_array[] = new int[len*2];

// 把原来array数组中的数据依次copy到new_array

for (int j = 0; j < len; ++j) {

new_array[j] = array[j];

}

// new_array复制给array，array现在大小就是2倍len了

array = new_array;

len = 2 * len;

}

// 将element放到下标为i的位置，下标i加一

array[i] = element;

++i;

}

```



当i < len时, 即 i = 0,1,2,...,n-1的时候，for循环不走，所以这n次的时间复杂度都是O(1);

当i >= len时, 即 i = n的时候，for循环进行数组的copy，所以只有这1次的时间复杂度是O(n);

最好时间复杂度 O(1)

最差时间复杂度 O(n)

(1+1+.....+n)/(n+1)

均摊时间复杂度 前n个的时间复杂度是 O(1) 最后一个O(n) 均摊到前面的时间上面去。

那么均摊时间复杂度就是 O(1)



## 05 数组：为什么很多编程语言中数组都从0开始编号

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

因为这个原因，所以导致操作的效率低效。

线性表， 数组，链表、队列、栈 都是线性表。

非线性表， 二叉树，堆，图。

因为连续的内存空间和相同类型的数据，有个杀手锏的特性 **随机访问**

\```

a[i]_address = base_address + i * data_type_size

\```

\### 插入操作

如果没有规律，那么可以将被插入的位置的数据放入末尾，新的数据放入，时间复杂度只有O(1)

\### 数组的访问越界问题

c语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。越界之后就会无限循环。

\#### 课后思考

前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。

JVM标记清除算法：

大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。

不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。

前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？

二维数组内存寻址：

对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：

address = base_address + ( i * n + j) * type_size

另外，对于数组访问越界造成无限循环，我理解是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。老师的程序，如果是内存地址递减的方式，就会造成无限循环。



